Clases grabadas donde voy:
Clase 0 - Concluida
Clase 1 - Concluida
Clase 2 - Concluida
Clase 3 - Concluida
Clase 4 - Concluida
Clase 5 - Concluida
Clase 6 - Concluida
Clase 7 - 
_______________________________________________________________________________________________

Verbos HTTP

GET -> Obtener la información del servidor.
POST -> Enviar información al servidor.
PUT -> Enviar información al servidor pero para actualizar (objeto completo).
        {
         "nombre": "azael",
         "apellidos": "garcia",
         "edad": 26
        }
PATCH -> Enviar información al servidor pero para actualizar (solo un atributo).
        Normalmente se usa en booleanos para cambiarlos
        {
         "nombre": "azael"
        }
DELETE -> Elimina información.

Son peticiones que hacemos al servidor.
_______________________________________________________________________________________________
Patrón de diseño MVC

M = Modelo -> Serían los esquemas de bases de datos. Nosotros creamos los modelos con Node y Express    
              definiendolos desde código y MongoDB ya crea las tablas en automático.
V = Vista -> La vista es el Frontend, usaremos React. Es la información que se pinta en la pantalla.
C = Controlador -> Es un intermediario entre el modelo y la vista. Es como un manejador de información.
________________________________________________________________________________________________
Mongoose es un ORM
O - Object
R - Relational
M - Mapping
Es una técnica que permite interactuar con la base de datos relacional y no relacional usando código orientado a objetos (métodos, funciones y clases). Convierte todo a un objeto. Traduce la estructura de una base datos. Las tablas, las filas, las columnas, etc. y los vuelve objetos.
________________________________________________________________________________________________
API también se le conoce como endpoint y hace referenecia a una URL.
API significa Interfaz de Programación de Aplicaciones
API es un conjunto de reglas y protocolos que permite a las aplicaciones comunicarse entre si. 
Las reglas son los verbos GET, POST, DELETE, PUT y PATCH.
Los protocolos son los http y https. El http no tiene un protocolo de certificado de seguridad. Es poco comun usar aplicaciones web sin el certificado. Por el momento se usa porque es local y se esta desarrollando.
Cuando las APIs ya están en internet, tiene que ser https si no el Frontend no las acepta. Es peligroso consumir http.

Ejemplo de URL de API: talkweb.com.mx/api/usuarios

La nuestra seria http://localhost:3000/api/usuarios
________________________________________________________________________________________________
En el archivo Usuario.js que es donde se declara, se le conoce como esquema
En el archivo usuariosController.js que es donde la base de datos ya existe, se le conoce como colecciones.
A las tablas se les conoce como colecciones.
Y a los registros se les conoce como documento.
________________________________________________________________________________________________
Autenticación
La dependencia jsonwebtoken es como un string cifrado con información. Ya esta instalada y se ve en el archivo package.json. Lo primero que se tiene que hacer es crear la autenticación, generar el Json Web Token. Primero autenticar y de ahi procesarlo. Se va a crear otro controlador, no será modelo.
Se creó el archivo authController.js en la carpeta controllers. 
A parte será la carpeta helpers. Los helpers son funciones utilitarias, son funciones que se pueden reutilizar para otras cosas. En este caso se usará para que genere el Json Web Token. Va a cifrar la información.
________________________________________________________________________________________________
Una vez hecha la autenticación, en Postman al poner POST y http://localhost:3000/api/auth/login, pongo un correo y password que esten en mi base de datos y que conozco, y me va a arrojar un token. Que es como el se ve abajo:

eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjY4OWNlNzU1MGI5ODBiMjI0OTE3Y2Q0MCIsImlhdCI6MTc1NTEyNTAyMiwiZXhwIjoxNzU3NzE3MDIyfQ.UcjbpJ6JFLZRRNCAA6btN3liiX6VBzyMAixZMzG7jnI

Si voy a jwt.io y pego ese token, me dará como resultado el id del usuario en cuestion.
________________________________________________________________________________________________
Los pasos son: 
Iniciamos sesión, validando las credenciales como correo y password, que es lo que meto en Postman
Me genera el JWT que es nuestra sesión y este token tiene la información de cuánto va a durar la sesión, en este caso 30 días y el id del usuario. 
Posteriormente debe haber algo que valide ese token y obtenga el perfil del usuario.

Para esto ultimo tenemos que hacer un Middleware que es como un intermediario. Estos Middlewarese ejecutan antes que los controladores.
Lo creamos validando el token y nos regresa el perfil, para posteriormente mandarlo al controlador.
________________________________________________________________________________________________
                                        Frontend
Crear interfaces con React y consumir la API creada en el backend.
Usaremos Vite Js
https://vite.dev/

Create React App se usaba antes para crear proyectos. Todavía se puede encontrar para dar mantenimiento.

https://create-react-app.dev/docs/getting-started/

Webpack 
Empaqueta todos los archivos del proyecto para subirlo a producción

https://webpack.js.org/

Babel Js es un transpilador de Js y lo que hace es transpilar el código moderno a código compatible con navegadores.

https://babeljs.io/

Resumiendo Vite ya hace todo el trabajo de empaquetar y transpilar.
________________________________________________________________________________________________
En el video de la Clase 5 viene como crear un proyecto. Al crearlo, me genera varias carpetas

Solo instalo node_modules.
En la carpeta Public normalmente se ponen los favicons.
En la carpeta src, hay una carpeta llamada assets que es donde ponemos imágenes, videos o audios del proyecto.

Se trabajará con una libreria de CSS llamada Material UI.
https://mui.com/
https://mui.com/material-ui/getting-started/

Antes de correr el proyecto, hay que instalar la libreria.

Para usar iconos, deben ser instalados, podemos usar el mismo Material UI
https://mui.com/material-ui/material-icons/
________________________________________________________________________________________________
React es una librería o biblioteca (coloquialmente se dice Framework) y se usa para crear Interfaces de Usuario. Fue creada por Facebook.
Combina HTML y JavaScript. Maneja funciones y retorna HTML. La extensión es .jsx

En el archivo App.jsx, maneja SPA o Single Page Application, que son aplicaciones de una sola página. Es decir, tenemos una app global y vamos metiendo componentes.

¿Qué es el jsx?
Significa JavaScript XML y es una extensión para JavaScript que nos permite escribir código similar a HTML dentro de los archivos JavaScript.

const nombre = "Azael"
inline experssion { nombre }

Creamos una variable y la podemos poner en la vista del navegador con esa sintaxis.

Una característica de React es lo que se llama el DOM virtual.

Por ejemplo en el siguiente código:
const enlaces = document.querySelectorAll("a");
console.log(enlaces);

se le llama DOM Scripting. Es Vanilla JavaScript. Por ejemplo en un contador tenemos que repintar todo en pantalla, y gasta mas recursos. Sería:
const boton = document.querySelector("button");
Let count = 0;
boton.innerHTML = count + 1;

En React el DOM Virtual es como una copia ligera que es puramente JavaScript. Ese DOM solo permanece en memoria. No de manera real. Por ejemplo en un contador solo se pinta lo que esta actualizándose. No se repinta todo. Sería:
const [count, setCount] = useState(0);

<button onClick={() => setCount((count) => count + 1)}>
        Count is {count}
</button>

En React un Hook es una función especial que permite enganchar las capacidades internas de React.
Refrescan una variable.

Por ejemplo aqui:

const [count, setCount] = useState(0);

Crea una variable y una función que refresca esa variable. Su valor inicial es 0.

useState es un Hook que lo que hace es refrescar el valor de una variable y a esto se le llama Reactividad, por eso el nombre de React.
Esto se refiere a que son variables que pueden mutar o cambiar su valor.

Hay variables no reactivas, es decir su valor no va a cambiar y se maneja la sintaxis tradicional:
const edad = 18

Para ver su valor ponemos:
<p> { edad } </p>

Dentro de los return solo podemos poner resultados y parte de la interfaz. No podemos poner if, forEach, etcétera. Solo podemos poner ternarios, por ejemplo:

<>
  { edad >= 18 ? <p>Eres mayor de edad</p> : <p>Eres menor de edad</p> }
</>

Estamos renderizando HTML condicional.

Tambien podemos usar map para iterar arreglos. Por ejemplo:
const meses = ["Enero", "Febrero", "Marzo", "Abril"];

return (
  <>
    {meses.map((mes) => (
      <p>mes</p>
    ))}
  </>
);

return (
//A esto se le llama fragment que es como un componente vacio. Solo se puede tener uno.
  <>
  
  </>
);

return (
//A esto se le llama fragment que es como un componente vacio. Solo se puede tener uno. Y también le puedo poner div.
  <div>
  
  </div>
);

//Esto ya no se puede hacer.
return (
  <>
  
  </>
  <p>
  
  </p>
);

//Otra cosa que podemos hacer es:
const edad = 18;

//Podemos poner return o renderizado condicional. El return lo que hace es terminar la ejecución del código o retornar un valor.
//Si se cumple el primer if se ejecuta lo que esta dentro y ya no pasa al siguiente return. Caso contrario, ejecuta el segundo return.

if (edad >= 18) {
  console.log("Eres mayor de edad");
  //return; // Termina la ejecución de la función
  return <p>Eres mayor de edad</p>; //Retorna un valor
}

return(
  <>
    <p>Eres menor de edad</p>
  </>
);
________________________________________________________________________________________________
En el hook useEffect, se debe tener mucho cuidado al usarlo ya que puede ciclar la aplicación, es decir, la app empieza a gastar y gastar RAM y se congela hasta que truena.

Su anatomía es la siguiente:
useEffect(() => {
  //Cuerpo del useEffect
  console.log(Ejecutandose....);
}, []);

Es un hook de React que lo que permite es realizar efectos secundarios en los componentes funcionales.
En el mismo archivo App.jsx esta un componente funcional.
function App() {

}

Se usa mas que nada en las peticiones a APIs, manipulación del DOM en renderizados, etcétera.
Se ejecuta al menos una vez, cada vez que se muestra un componente.
En este caso la function App es el componente principal. El useEffect se ejecutará cada vez que se recargue el sitio web.

useEffect(() => {
  //Cuerpo del useEffect
  console.log(`Cambio el valor ${count}`);
}, []);

En este ejemplo se ejecuta una sola vez al pintarse o cambia el componente.

Para que se vuelva a ejecutar necesitamos pasarle en el arreglo la variable count.

useEffect(() => {
  //Cuerpo del useEffect
  console.log(`Cambio el valor ${count}`);
}, [count]);

De esta forma cada vez que count cambia, se ejecuta el useEffect.
Por ejemplo, cambia un codigo postal, y en useEffect pide todos los puntos con ese código.

En desarrollo, en la consola se ejecuta dos veces. En producción solo se ejecuta una sola vez.
Esto porque se ejecuta el modo estricto. Porque a la hora de montar la aplicación ejecuta los efectos (useEffect), los desmonta y vuelva a montar.

Los componentes son fragmentos de código que son reutilizables.

Puedo borrar App.css, index.css

________________________________________________________________________________________________
La librería de Material UI nos ermite usar componentes ya diseñados.
Por ejemplo:
Typography .- Me permite poner texto y como lo voy a usar, si como h1-h6, párrafo, etcétera.
<Typography variant="body2">Desde inicio de sesión.</Typography>;

Box.- Me permite crear un contenedor padre y le indico que sea un div, header, nav, etcétera.
La ventaja es que box es un componente que nos permite escribir CSS más sencillo.

<Box
  component="div"
  sx={{
    //Objeto CSS
    display: "flex",
    justifyContent: "space-between"
  }}
>
  <Typography>HOLA</Typography>
  <Typography>adios</Typography>
</Box>


Otra forma sería:
const stylesGlobals = {
  display: "flex",
  justifyContent: "space-between"
};

<Box component="div" sx={stylesGlobals}>
  <Typography>HOLA</Typography>
  <Typography>adios</Typography>
</Box>


Otra forma es crear una carpeta llamada styles y dentro un archivo llamado style.js.
Dentro iría:

export const stylesGlobals = {
  display: "flex",
  justifyContent: "space-between"
};

Y en el archivo del componente pondríamos:

import { stylesGlobals } from "-/styles/styles";

<Box component="div" sx={stylesGlobals}>
  <Typography>HOLA</Typography>
  <Typography>adios</Typography>
</Box>


Si utilizo como tal la etiqueta div, en lugar de usar la propiedad sx, utilizo la propiedad style. Por ejemplo:
<div
  style={{
    display: "flex",
    justifyContent: "space.between"
  }}
>
  <p>Hola</p>
</div>



Para manejar diferentes estilos para los tamaños de pantallas, en lugar de usar los media queries, Material UI utiliza etiquetas como xs (xtra small), s (small), md (medium), l (large), xl (xtra large)

La forma de ponerlo es:
sx={{ 
  display: { xs: "none", md: "block" }, //Objeto de tamaños de pantallas
  //Más estilos
}}

El stack que manejamos es MERN (Mongo, Express, React, Node).

Existen lo que se llama estados locales y estados globales.
Los estados locales (useState) solo son estados de un solo componente.
Por ejemplo en Login donde se creará un estado para guardar contraseña y correo para utilizarlos en una API.
Los globales  son reutilizables o dependen de otros componentes.
Por ejemplo usuarios y clientes

El manejo de las APIs serán globales. 
________________________________________________________________________________________________

________________________________________________________________________________________________

________________________________________________________________________________________________